#pragma config(Sensor, in1,    light,          sensorReflection)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  switch_,        sensorTouch)
#pragma config(Sensor, dgtl7,  ultrasonic,     sensorSONAR_cm)
#pragma config(Sensor, dgtl10, leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port1,           right,         tmotorVex393, openLoop)
#pragma config(Motor,  port2,           fun,           tmotorVex393, openLoop)
#pragma config(Motor,  port10,          left,          tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Authors: Murun, Aidan, and Elle

// function declarations
void debug();
void autoDrive(int distanceToLeftWall);
void turnRight(int angle, int speed);
void stopBot();
void startBot(int leftMotorSpeed, int rightMotorSpeed, int funMotorSpeed);
void reverse(int msec, int speed);
void zeroEncoders();
int getRightEncoder();
int getLeftEncoder();
int putInRange(int candidateValue);

// GLOBAL VARIABLES:
// default motor speeds
const int MOTOR_SPEED = 30;
const int FUN_MOTOR_SPEED = 100;

task main()
{
	// start navigation only after switch has been activated
	while (!SensorValue[switch_]) {}

	// reset encoders to 0
	zeroEncoders();

	// kick off the autonomous with default motor speed
	startBot(MOTOR_SPEED, MOTOR_SPEED, FUN_MOTOR_SPEED);

	// move forward 1 sec to enter maze
	wait1Msec(1010);

	// main loop
	while (true)
	{
		// if too close to wall, reverse, and turn right
		if (SensorValue[light] >= 320)
		{
			// backup
			reverse(400, 25);

			// turn right
			turnRight(140, 50);
		}
		// otherwise drive straight or turn left, keeping given distance from wall
		autoDrive(16);
	}
}

// maintain a targetDistance from left wall using a P-only stability feedback
void autoDrive(int targetDistance)
{	
	// get the current distance from wall
	int actualDistance = SensorValue[ultrasonic];
	int distanceError = actualDistance-targetDistance;
	int adjustedSpeed = (MOTOR_SPEED + 10 * abs(distanceError));
	adjustedSpeed = putInRange(adjustedSpeed);
	
	// check if the current distance from wall is too close to wall or too far from wall
	if (distanceError > 1)
	{
		// right motor moves with P gain and left is default motor speed (minus 15)
		motor[left] = MOTOR_SPEED - 15;
		motor[right] = adjustedSpeed;
	}
	else if(distanceError < -1)
	{
		// left motor moves with P gain and right is default motor speed (minus 15)
		motor[left] = adjustedSpeed;
		motor[right] = MOTOR_SPEED - 15;
	}
	else
	{
		// increase speed on straight-away
		motor[left] = 70;
		motor[right] = 70;
	}
}

// this function turns right by turning both wheels using the encoder to ensure POINT TURNS
// NOTE: pass an angle value of ~170 to turn 90 degrees
void turnRight(int angle, int speed)
{
	// reset both encoders to 0
	zeroEncoders();

	// values to store our current encoder values
	int leftEncVal = 0;
	int rightEncVal = 0;

	// to turn right, left and right need to be alternate
	int leftTarget = angle;
	int rightTarget = -angle;

	// turns so long as one of the encoders does NOT register its target encoder value
	while (leftEncVal <= leftTarget || rightEncVal >= rightTarget)
	{
		// run if the left hasn't reached the target encoder
		if (leftEncVal <= leftTarget)
		{
			motor[left] = speed;
			// update the current left encoder
			leftEncVal = SensorValue[leftEncoder];
		}
		// run if the right hasn't reached the target encoder
		if (rightEncVal >= rightTarget)
		{
			motor[right] = -speed;
			// update the current right encoder
			rightEncVal = SensorValue[rightEncoder];
		}
	}
}

// returns value within bounds if candidateValue is over certain boundary,
// otherwise returns candidateValue
int putInRange(int candidateValue) {
	if (candidateValue > 127)
	{
		return 100;
	}
	else if (candidateValue < -127)
	{
		return -100;
	}
	else {
		return candidateValue;
	}
}

// stops bot
void stopBot()
{
	motor[left] = 0;
	motor[right] = 0;
}

// changes all motors to given speeds
void startBot(int leftMotorSpeed, int rightMotorSpeed, int funMotorSpeed) {
	motor[left] = leftMotorSpeed;
	motor[right] = rightMotorSpeed;
	motor[fun] = funMotorSpeed;
}

// reverses bot for given time in msec
void reverse(int msec, int speed)
{
	motor[left] = -speed;
	motor[right] = -speed;
	wait1Msec(msec);
	stopBot();
}

// changes both encoder values to 0
void zeroEncoders() {
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
}

// returns the left encoder (forward is positive, back is negative)
int getLeftEncoder()
{
	return (-1 * (SensorValue[leftEncoder]));
}

// returns the right encoder (forward is positive, back is negative)
int getRightEncoder()
{
	return (SensorValue[rightEncoder]);
}

// prints sensor vals
void debug()
{
	writeDebugStream("leftS %d, frontS: %d", SensorValue[ultrasonic], SensorValue[light]);
	writeDebugStreamLine("Encoder: %d", getLeftEncoder());
	writeDebugStreamLine("Encoder: %d", getRightEncoder());
}
